The design of this web-app is built largely through different components interacting with each other, maintaining simplicity in theme and concept as much as possible. In terms of building a website, I've kept it very simple by only including one page, containing almost everything you need to know about the 

Using a react-app automatically installs a substantial amount of base implementation, much of which I've maintained. All of the modules within node_modules have not been manually changed; these were installed with Node. In public, much of the outward-facing code, including the actual html file, is stored. Public, for the sake of simplicity, has also not been modified much, beyond minor changes in index.html for the website name and manifest.json, which updates mobile viewing. Source contains the vast majority of new code, including all of my components. 

Beginning with index.js, this takes app.js and renders it into the root element, which is then inserted into the html file. App.js combines TextInputForm.js and Explanation.js components, using a container and CSS to display the components dyanmically using flex, which I thought combines the two elements most elegantly, especially on desktop. Explanation includes a short description of the philosophy behind the app--essentially an "about" page, but to keep things simple, I decided that I didn't want to expand the website beyond what it's meant to do just to include additional somewhat-extraneous pages. Juxtaposing these two elements together also asks the user to contend with the explanation. What's the point of this program? Well, the explanation is right there. 

I previously also thought about including a log of misspellings——or an option that allowed you to save certain misspellings that you particularly enjoyed, but I realized that I wanted to maintain the spontaneity of the misspellings, almost as momentary glitches. There is a diversity of different misspellings for a given input, and by keeping the misspellings ephemeral, the user wouldn't be encouraged to privilege one misspelling over another. 

In TextInputForm, I used the React useState hook to take textinput and then call Misspell to return the misspelled text. Misspell is embedded within the TextInputForm component, and uses axios to send a POST request to openai's chat completions with certain conditions that returns misspelled text inside a textbox which again is included inside the TextInputForm component. By using a try catch finally model in Misspell, I was also able to include a loading sign that showed the program's progress. Also included inside Misspell is the use of the API key (taken from .env) to access OpenAI, which I integrated within the try catch finally sequence. Zooming back out, these are all of the components that I modified from the base React web-app model. 

For this project, I wanted to focus on implementing this misspelling function cleanly and elegantly, and hopefully it presents an interesting example of the intersection between technology, creativity, and art. 